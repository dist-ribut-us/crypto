package crypto

// This is a straight up copy of seal and open from
// golang.org/x/crypto/nacl/secretbox
//
// It is necessary for onion routing.

import (
	"golang.org/x/crypto/salsa20/salsa"
)

// UnmacdSeal appends an encrypted copy of message to out, which must not
// overlap message. The key and nonce pair must be unique for each distinct
// message and the output will be Overhead bytes longer than message. Unlike
// secretbox.Seal, it does not MAC the data. It should only be use on top of
// a MAC'd ecnryption, as in onion routing.
func (shared *Shared) UnmacdSeal(message []byte, nonce *Nonce) []byte {
	out := make([]byte, len(message))
	ret := out
	subKey := &key{}
	var counter [16]byte
	setup(subKey, &counter, nonce, shared)

	var firstBlock [64]byte
	salsa.XORKeyStream(firstBlock[:], firstBlock[:], &counter, subKey.arr())

	// We XOR up to 32 bytes of message with the keystream generated from
	// the first block.
	firstMessageBlock := message
	if len(firstMessageBlock) > 32 {
		firstMessageBlock = firstMessageBlock[:32]
	}
	for i, x := range firstMessageBlock {
		out[i] = firstBlock[32+i] ^ x
	}
	message = message[len(firstMessageBlock):]
	out = out[len(firstMessageBlock):]

	// Now encrypt the rest.
	counter[8] = 1
	salsa.XORKeyStream(out, message, &counter, subKey.arr())

	return ret
}

func setup(subKey *key, counter *[16]byte, nonce *Nonce, shared *Shared) {
	// We use XSalsa20 for encryption so first we need to generate a
	// key and nonce with HSalsa20.
	var hNonce [16]byte
	copy(hNonce[:], nonce[:])
	salsa.HSalsa20(subKey.arr(), &hNonce, shared.Arr(), &salsa.Sigma)

	// The final 8 bytes of the original nonce form the new nonce.
	copy(counter[:], nonce[16:])
}

// UnmacdOpen decrypts a box produced by UnmacdSeal and appends the message to
// out, which must not overlap box. The output will be Overhead bytes smaller
// than box. The unsealed box has not been MAC'd and the data should not be
// trusted unless there is an underlying MAC (as in onion routing)
func (shared *Shared) UnmacdOpen(cipher []byte, nonce *Nonce) []byte {
	subKey := &key{}
	var counter [16]byte
	setup(subKey, &counter, nonce, shared)

	// The Poly1305 key is generated by encrypting 32 bytes of zeros. Since
	// Salsa20 works with 64-byte blocks, we also generate 32 bytes of
	// keystream as a side effect.
	var firstBlock [64]byte
	salsa.XORKeyStream(firstBlock[:], firstBlock[:], &counter, subKey.arr())

	//ret, out := sliceForAppend(out, len(cipher)-Overhead)
	ret := make([]byte, len(cipher))
	out := ret

	// We XOR up to 32 bytes of cipher with the keystream generated from
	// the first block.
	firstMessageBlock := cipher
	if len(firstMessageBlock) > 32 {
		firstMessageBlock = firstMessageBlock[:32]
	}
	for i, x := range firstMessageBlock {
		out[i] = firstBlock[32+i] ^ x
	}

	cipher = cipher[len(firstMessageBlock):]
	out = out[len(firstMessageBlock):]

	// Now decrypt the rest.
	counter[8] = 1
	salsa.XORKeyStream(out, cipher, &counter, subKey.arr())

	return ret
}
